---
title: "rstudio::conf 2022 recap"
author: "Stephen Turner"
date: "July 25-28, 2022"
link-external-newwindow: true
format: 
  revealjs:
    # chalkboard: true
    self-contained: true
    code-line-numbers: false
    transition: fade
    height: 900
    width: 1600
    logo: images/sigsci-logo.png
    footer: "[strnr.quarto.pub/rstudioconf-2022-recap](https://strnr.quarto.pub/rstudioconf-2022-recap)"
    slide-number: c/t
    mermaid-format: png
editor: visual
execute: 
  eval: false
  echo: true
---

## Highlights

-   RStudio PBC is now Posit
-   Tidymodels for ML training, evaluation, and deployment
-   Quarto
-   Shiny for Python & Serverless Shiny
-   Miscellaneous

# RStudio is now Posit

## RStudio PBC is now Posit

![](images/posit.jpg){fig-align="center"}

## RStudio PBC is now Posit

-   2020: RStudio became a Public Benefit Corporation, recognized as a Certified B Corporation ([blog post](https://www.rstudio.com/blog/rstudio-pbc/)).

-   Long-term focus on sustainable open-source software development for data science.

    -   What will they keynote at rstudio::conf 2122 look like?

    -   RStudio is becoming more multilingual (see also Quarto)

    -   R, Python, Julia, etc. may be long-dead languages.

-   2022: RStudio becomes Posit

    -   Blog post: [rstudio.com/blog/rstudio-is-becoming-posit](https://www.rstudio.com/blog/rstudio-is-becoming-posit/)

    -   More info: <https://posit.co/>

# Tidymodels

## Tidymodels: Overview

-   Collection of packages for machine learning using tidyverse principles
-   caret is no longer being developed
-   Tidymodels is ready for production. CRAN 1.0.x releases
-   *Extremely* well documented. See [tidymodels.org](https://www.tidymodels.org/)
-   Workshop materials: [workshops.tidymodels.org](https://workshops.tidymodels.org/)

## Tidymodels: simple linear regression

Compare base R versus tidymodels for a simple linear regression:

::: columns
::: {.column width="50%"}
Using base `stats::lm()`:

```{r}
lmfit <- lm(mpg~., data=mtcars)
```
:::

::: {.column width="50%"}
Using tidymodels workflows + parsnip:

```{r}
library(tidymodels)
tmfit <- 
  workflow() %>% 
  add_model(linear_reg()) %>% 
  add_formula(mpg~.) %>% 
  fit(data=mtcars)
```
:::
:::

## Tidymodels: boosted trees

::: columns
::: {.column width="50%"}
Set up workflow:

```{r}
#| code-line-numbers: "|1-9|11-16|18-22|1-22|1-9|21"
# Boosted tree spec 
xgb_spec <-
  boost_tree(
    trees = 500, min_n = tune(), 
    stop_iter = tune(), tree_depth = tune(),
    learn_rate = tune(), loss_reduction = tune()
  ) %>%
  set_mode("classification") %>% 
  set_engine("xgboost")

# Boosted tree recipe
xgb_rec <- 
  recipe(on_goal ~ ., data = nhl_train) %>% 
  step_lencode_mixed(player, outcome=vars(on_goal)) %>% 
  step_dummy(all_nominal_predictors()) %>%
  step_zv(all_predictors())

# Boosted tree workflow
xgb_wflow <- 
  workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(xgb_rec)

```
:::

::: {.column width="50%"}
Find optimal parameters with cross-validation using a Latin hypercube grid search:

```{r}
grid <- 
  xgb_wflow %>% 
  extract_parameter_set_dials() %>% 
  grid_latin_hypercube(size = 25)

xgb_res <- 
  xgb_wflow %>% 
  tune_grid(resamples=nhl_val, grid=grid)
xgb_res
```
:::
:::

## Tidymodels: usemodels

Run this:

```{r}
usemodels::use_ranger(mpg~., data=mtcars)
```

. . .

Copied to the clipboard:

```{r}
#| code-line-numbers: "|1-2|4-7|9-12|14-18"
ranger_recipe <- 
  recipe(formula = mpg ~ ., data = mtcars, clipboard = TRUE) 

ranger_spec <- 
  rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>% 
  set_mode("regression") %>% 
  set_engine("ranger") 

ranger_workflow <- 
  workflow() %>% 
  add_recipe(ranger_recipe) %>% 
  add_model(ranger_spec) 

set.seed(38757)
ranger_tune <-
  tune_grid(ranger_workflow, 
            resamples = stop("add your rsample object"), 
            grid = stop("add number of candidate points"))

```

## Tidymodels: usemodels

Run this:

```{r}
usemodels::use_glmnet(mpg~., data=mtcars)
```

. . .

Copied to the clipboard:

```{r}
glmnet_recipe <- 
  recipe(formula = mpg ~ ., data = mtcars) %>% 
  step_zv(all_predictors()) %>% 
  step_normalize(all_numeric_predictors()) 

glmnet_spec <- 
  linear_reg(penalty = tune(), mixture = tune()) %>% 
  set_mode("regression") %>% 
  set_engine("glmnet") 

glmnet_workflow <- 
  workflow() %>% 
  add_recipe(glmnet_recipe) %>% 
  add_model(glmnet_spec) 

glmnet_grid <- tidyr::crossing(penalty = 10^seq(-6, -1, length.out = 20), 
                               mixture = c(0.05, 0.2, 0.4, 0.6, 0.8, 1)) 

glmnet_tune <- 
  tune_grid(glmnet_workflow, 
            resamples = stop("add your rsample object"), 
            grid = glmnet_grid) 
```

## Tidymodels: usemodels

Run this:

```{r}
usemodels::use_xgboost(mpg~., data=mtcars)
```

. . .

Copied to the clipboard:

```{r}
xgboost_recipe <- 
  recipe(formula = mpg ~ ., data = mtcars, clipboard = TRUE) %>% 
  step_zv(all_predictors()) 

xgboost_spec <- 
  boost_tree(trees = tune(), min_n = tune(), 
             tree_depth = tune(), learn_rate = tune(), 
             loss_reduction = tune(), sample_size = tune()) %>% 
  set_mode("regression") %>% 
  set_engine("xgboost") 

xgboost_workflow <- 
  workflow() %>% 
  add_recipe(xgboost_recipe) %>% 
  add_model(xgboost_spec) 

set.seed(9270)
xgboost_tune <-
  tune_grid(xgboost_workflow, 
            resamples = stop("add your rsample object"), 
            grid = stop("add number of candidate points"))

```

## Tidymodels + vetiver + plumber = ðŸ”®

-   plumber ([rplumber.io](https://www.rplumber.io/)): Automatically generate HTTP API for R functions.
-   vetiver ([rstudio.github.io/vetiver-r](https://rstudio.github.io/vetiver-r/)): version, share, deploy, and monitor a trained model.

::: columns
::: {.column width="50%"}

Model training and deployment. Do this in one R session.

```{r}
library(tidymodels)
library(vetiver)
library(plumber)

# Not the way you'd actually split data - for demo only
cars_train <- mtcars[1:24,]
cars_test <- mtcars[25:32,]

# Random forest using C++ implementation
rf_spec <-
  rand_forest(trees=1000) %>%
  set_mode("regression") %>%
  set_engine("ranger")

# Simple workflow
rf_wflow <- workflow(mpg~., rf_spec)

# Fit the model
rf_fit <- fit(rf_wflow, cars_train)

# Create a vetiver model object
v <- vetiver_model(rf_fit, "mtcars_mpg")

# Create a plumber API
pr <- pr() %>% vetiver_api(v)

# Run the API server, open at http://127.0.0.1:5678/
pr_run(pr, port=5678)
```
:::

::: {.column width="50%"}

Predict from the model endpoint. Do this in a separate session. 

```{r}
library(vetiver)

# Use the same IP/port from above
endpoint <- vetiver_endpoint("http://127.0.0.1:5678/predict")

# same split from above
cars_test <- mtcars[25:32,]

# Predict from the endpoint (returns a 1-col tibble)
predict(endpoint, cars_test)

# Stick this onto the original data, plot, etc.
cbind(cars_test, predict(endpoint, cars_test))
```
:::
:::

## Model workflow

Consider simple preprocessing (e.g., centering/scaling numeric predictors), simple feature engineering (e.g., PCA), followed by vanilla GLM/tree model.

Wrong:

```{mermaid}
%%| fig-width: 12
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '10px'}}}%%
graph LR
  Data --> P[Preprocessing]
  Predictors --> P
  P --> S[Split <br/> Training/testing]
  S --> Modeling
  subgraph "Model Workflow"
  Modeling
  end
  Modeling --> F[Fitted Model]
```

. . . 

Tidymodels makes this easy: 

```{mermaid}
%%| fig-width: 12
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '10px'}}}%%
graph LR
  Data --> S[Split <br/> Training/testing]
  Predictors --> S
  subgraph "Model Workflow"
  S --> P[Preprocessing]
  P --> Modeling
  end
  Modeling --> F[Fitted Model]
```


# Quarto

## We ~~don't~~ talk about Quarto

See Alison Hill's [blog post](https://www.apreshill.com/blog/2022-04-we-dont-talk-about-quarto/) from April

[![](images/quarto-bruno.jpg)](https://www.apreshill.com/blog/2022-04-we-dont-talk-about-quarto/)

## What is Quarto?

-   Quarto is an open-source scientific and technical publishing system built on Pandoc.
-   `quarto` is a language agnostic command line interface (CLI).
-   "Batteries included" -- RStudio now comes with the `quarto` CLI installed.
-   <https://quarto.org/>

. . .

``` bash
sturner$ quarto --help
```

. . .

``` bash
  Usage:   quarto
  Version: 1.0.36

  Options:
    -h, --help     - Show this help.                            
    -V, --version  - Show the version number for this program.  

  Commands:
    render          [input] [args...]   - Render input file(s) to various document types.            
    preview         [file] [args...]    - Render and preview a document or website project.          
    serve           [input]             - Serve a Shiny interactive document.                        
    create-project  [dir]               - Create a project for rendering multiple documents          
    convert         <input>             - Convert documents to alternate representations.            
    pandoc          [args...]           - Run the version of Pandoc embedded within Quarto.          
    run             [script] [args...]  - Run a TypeScript, R, Python, or Lua script.                
    install         <type> [target]     - Installs an extension or global dependency.                
    publish         [provider] [path]   - Publish a document or project. Available providers include:
    check           [target]            - Verify correct functioning of Quarto installation.         
```

## What is Quarto?

```{mermaid}
%%| fig-width: 12
%%{init: {'theme': 'neutral', 'themeVariables': { 'fontSize': '10px'}}}%%
graph LR
  Q(.qmd) --> K(knitr)
  Q --> J(Jupyter)
  J & K --> M(.md)
  M --> P(Pandoc)
  P -- Report --> R(.pdf <br/> .docx)
  P -- Presentation --> RJS(revealjs <br/> Beamer <br/> Powerpoint)
  P -- Project --> PRJ(Books <br/> Websites)

```

## What is Quarto?

-   A `.qmd` is a plain text file
-   Regular Rmarkdown mostly "just works"
-   Chunk options are YAML using the hashpipe (e.g., `#| echo: false`)
-   One document, many formats
-   This slideshow:
    -   Rendered: [strnr.quarto.pub/rstudioconf-2022-recap](https://strnr.quarto.pub/rstudioconf-2022-recap)
    -   Source: [github.com/stephenturner/rstudioconf2022](https://github.com/stephenturner/rstudioconf2022)
    -   Demo: chalkboard, outline, annotations
-   *BDSR* Book (outline): [bdsr.netlify.app](https://bdsr.netlify.app/)

# Shiny for Python

## Shiny for Python

-   Similar conceptually to Shiny for R, and designed to feel like idiomatic Python

-   Documentation: <https://shiny.rstudio.com/py>.

-   Deployment options include shinyapps.io, RStudio Connect, Shiny Server Open Source, and on a static server.

## Shiny for Python

Minimal example:

``` py
from shiny import App, render, ui
app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)
def server(input, output, session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"
app = App(app_ui, server)
```

## Shinylive: Serverless Shiny

-   Shiny for Python running completely in the browser, no server required
-   Powered by WebAssembly and Pyodide
    -   WebAssembly (WASM): binary format for compiled programs that can run in a web browser at near-native speeds. [webassembly.org](https://webassembly.org/)
    -   Pyodide: Port of CPython to WASM. [pyodide.org](https://pyodide.org/en/stable/)
-   No installation needed: no shiny, no python.
-   Easy deployment (any static web hosting service)
-   Security: runs in browser sandbox

## Shinylive: example

URL: [stephenturner.github.io/shinypy-helloworld](https://stephenturner.github.io/shinypy-helloworld)

Code: [github.com/stephenturner/shinypy-helloworld](https://github.com/stephenturner/shinypy-helloworld){.uri}

``` python
from shiny import App, render, ui

# Import modules for plot rendering
import numpy as np
import matplotlib.pyplot as plt

app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.panel_sidebar(
            ui.input_slider("n", "N", 0, 100, 20),
        ),
        ui.panel_main(
            ui.output_plot("plot"),
        ),
    ),
)


def server(input, output, session):
    @output
    @render.plot(alt="A histogram")
    def plot():
        np.random.seed(19680801)
        x = 100 + 15 * np.random.randn(437)

        fig, ax = plt.subplots()
        ax.hist(x, input.n(), density=True)
        return fig


app = App(app_ui, server, debug=True)
```

# Miscellaneous

## GSK talks
